/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.15.8
 * source: net.proto
 * git: https://github.com/thesayyn/protoc-gen-ts
 * buymeacoffee: https://www.buymeacoffee.com/thesayyn
 *  */
import * as pb_1 from "google-protobuf";
export namespace proto {
    export enum InstructionType {
        OFPIT_INVALID = 0,
        OFPIT_GOTO_TABLE = 1,
        OFPIT_WRITE_METADATA = 2,
        OFPIT_WRITE_ACTIONS = 3,
        OFPIT_APPLY_ACTIONS = 4,
        OFPIT_CLEAR_ACTIONS = 5,
        OFPIT_METER = 6,
        OFPIT_EXPERIMENTER = 65535
    }
    export enum CommandResultType {
        OUTPUT = 0,
        ERROR = 1,
        END_SIGNAL = 100
    }
    export class Host extends pb_1.Message {
        constructor(data?: any[] | ({} & (({
            name?: string;
        }) | ({
            ip?: string;
        }) | ({
            mac?: string;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[1], [2], [3]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("ip" in data && data.ip != undefined) {
                    this.ip = data.ip;
                }
                if ("mac" in data && data.mac != undefined) {
                    this.mac = data.mac;
                }
            }
        }
        get name() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set name(value: string) {
            pb_1.Message.setOneofField(this, 1, [1], value);
        }
        get ip() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set ip(value: string) {
            pb_1.Message.setOneofField(this, 2, [2], value);
        }
        get mac() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set mac(value: string) {
            pb_1.Message.setOneofField(this, 3, [3], value);
        }
        get _name() {
            const cases: {
                [index: number]: "none" | "name";
            } = {
                0: "none",
                1: "name"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        get _ip() {
            const cases: {
                [index: number]: "none" | "ip";
            } = {
                0: "none",
                2: "ip"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        get _mac() {
            const cases: {
                [index: number]: "none" | "mac";
            } = {
                0: "none",
                3: "mac"
            };
            return cases[pb_1.Message.computeOneofCase(this, [3])];
        }
        toObject() {
            const data: {
                name?: string;
                ip?: string;
                mac?: string;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.ip != null) {
                data.ip = this.ip;
            }
            if (this.mac != null) {
                data.mac = this.mac;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.name === "string" && this.name.length)
                writer.writeString(1, this.name);
            if (typeof this.ip === "string" && this.ip.length)
                writer.writeString(2, this.ip);
            if (typeof this.mac === "string" && this.mac.length)
                writer.writeString(3, this.mac);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Host {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Host();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.ip = reader.readString();
                        break;
                    case 3:
                        message.mac = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Host {
            return Host.deserialize(bytes);
        }
    }
    export class Switch extends pb_1.Message {
        constructor(data?: any[] | ({} & (({
            name?: string;
        }) | ({
            datapath_id?: string;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[1], [2]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("datapath_id" in data && data.datapath_id != undefined) {
                    this.datapath_id = data.datapath_id;
                }
            }
        }
        get name() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set name(value: string) {
            pb_1.Message.setOneofField(this, 1, [1], value);
        }
        get datapath_id() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set datapath_id(value: string) {
            pb_1.Message.setOneofField(this, 2, [2], value);
        }
        get _name() {
            const cases: {
                [index: number]: "none" | "name";
            } = {
                0: "none",
                1: "name"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        get _datapath_id() {
            const cases: {
                [index: number]: "none" | "datapath_id";
            } = {
                0: "none",
                2: "datapath_id"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        toObject() {
            const data: {
                name?: string;
                datapath_id?: string;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.datapath_id != null) {
                data.datapath_id = this.datapath_id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.name === "string" && this.name.length)
                writer.writeString(1, this.name);
            if (typeof this.datapath_id === "string" && this.datapath_id.length)
                writer.writeString(2, this.datapath_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Switch {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Switch();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.datapath_id = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Switch {
            return Switch.deserialize(bytes);
        }
    }
    export class Link extends pb_1.Message {
        constructor(data?: any[] | ({} & (({
            name?: string;
        }) | ({
            host1?: string;
        }) | ({
            host2?: string;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[1], [2], [3]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("host1" in data && data.host1 != undefined) {
                    this.host1 = data.host1;
                }
                if ("host2" in data && data.host2 != undefined) {
                    this.host2 = data.host2;
                }
            }
        }
        get name() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set name(value: string) {
            pb_1.Message.setOneofField(this, 1, [1], value);
        }
        get host1() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set host1(value: string) {
            pb_1.Message.setOneofField(this, 2, [2], value);
        }
        get host2() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set host2(value: string) {
            pb_1.Message.setOneofField(this, 3, [3], value);
        }
        get _name() {
            const cases: {
                [index: number]: "none" | "name";
            } = {
                0: "none",
                1: "name"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        get _host1() {
            const cases: {
                [index: number]: "none" | "host1";
            } = {
                0: "none",
                2: "host1"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        get _host2() {
            const cases: {
                [index: number]: "none" | "host2";
            } = {
                0: "none",
                3: "host2"
            };
            return cases[pb_1.Message.computeOneofCase(this, [3])];
        }
        toObject() {
            const data: {
                name?: string;
                host1?: string;
                host2?: string;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.host1 != null) {
                data.host1 = this.host1;
            }
            if (this.host2 != null) {
                data.host2 = this.host2;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.name === "string" && this.name.length)
                writer.writeString(1, this.name);
            if (typeof this.host1 === "string" && this.host1.length)
                writer.writeString(2, this.host1);
            if (typeof this.host2 === "string" && this.host2.length)
                writer.writeString(3, this.host2);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Link {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Link();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.host1 = reader.readString();
                        break;
                    case 3:
                        message.host2 = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Link {
            return Link.deserialize(bytes);
        }
    }
    export class Packet extends pb_1.Message {
        constructor(data?: any[] | {
            fields?: Map<string, string>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("fields" in data && data.fields != undefined) {
                    this.fields = data.fields;
                }
            }
            if (!this.fields)
                this.fields = new Map()
        }
        get fields() {
            return pb_1.Message.getField(this, 1) as any as Map<string, string>;
        }
        set fields(value: Map<string, string>) {
            pb_1.Message.setField(this, 1, (value as any));
        }
        toObject() {
            const data: {
                fields?: {
                    [key: string]: string;
                };
            } = {};
            if (this.fields.size > 0) {
                data.fields = Object.fromEntries(this.fields);
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            for (const [key, value] of this.fields) {
                writer.writeMessage(1, this.fields, () => {
                    writer.writeString(1, key);
                    writer.writeString(2, value);
                })
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Packet {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Packet();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary((message.fields as any), reader, reader.readString, reader.readString));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Packet {
            return Packet.deserialize(bytes);
        }
    }
    export class Action extends pb_1.Message {
        constructor(data?: any[] | ({} & (({
            str?: string;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[1]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("str" in data && data.str != undefined) {
                    this.str = data.str;
                }
            }
        }
        get str() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set str(value: string) {
            pb_1.Message.setOneofField(this, 1, [1], value);
        }
        get _str() {
            const cases: {
                [index: number]: "none" | "str";
            } = {
                0: "none",
                1: "str"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        toObject() {
            const data: {
                str?: string;
            } = {};
            if (this.str != null) {
                data.str = this.str;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.str === "string" && this.str.length)
                writer.writeString(1, this.str);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Action {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Action();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.str = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Action {
            return Action.deserialize(bytes);
        }
    }
    export class ActionSet extends pb_1.Message {
        constructor(data?: any[] | {
            actions?: Action[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("actions" in data && data.actions != undefined) {
                    this.actions = data.actions;
                }
            }
        }
        get actions() {
            return pb_1.Message.getRepeatedWrapperField(this, Action, 1) as Action[];
        }
        set actions(value: Action[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        toObject() {
            const data: {
                actions?: ReturnType<typeof Action.prototype.toObject>[];
            } = {};
            if (this.actions != null) {
                data.actions = this.actions.map((item: Action) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.actions !== undefined)
                writer.writeRepeatedMessage(1, this.actions, (item: Action) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ActionSet {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ActionSet();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.actions, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Action.deserialize(reader), Action));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ActionSet {
            return ActionSet.deserialize(bytes);
        }
    }
    export class Instruction extends pb_1.Message {
        constructor(data?: any[] | ({} & (({
            goto_table?: InstructionGotoTable;
            write_metadata?: never;
            actions?: never;
            meter?: never;
        } | {
            goto_table?: never;
            write_metadata?: InstructionWriteMetadata;
            actions?: never;
            meter?: never;
        } | {
            goto_table?: never;
            write_metadata?: never;
            actions?: InstructionActions;
            meter?: never;
        } | {
            goto_table?: never;
            write_metadata?: never;
            actions?: never;
            meter?: InstructionMeter;
        }) | ({
            type?: InstructionType;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[2, 3, 4, 5], [1]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("goto_table" in data && data.goto_table != undefined) {
                    this.goto_table = data.goto_table;
                }
                if ("write_metadata" in data && data.write_metadata != undefined) {
                    this.write_metadata = data.write_metadata;
                }
                if ("actions" in data && data.actions != undefined) {
                    this.actions = data.actions;
                }
                if ("meter" in data && data.meter != undefined) {
                    this.meter = data.meter;
                }
            }
        }
        get type() {
            return pb_1.Message.getField(this, 1) as InstructionType;
        }
        set type(value: InstructionType) {
            pb_1.Message.setOneofField(this, 1, [1], value);
        }
        get goto_table() {
            return pb_1.Message.getWrapperField(this, InstructionGotoTable, 2) as InstructionGotoTable;
        }
        set goto_table(value: InstructionGotoTable) {
            pb_1.Message.setOneofWrapperField(this, 2, [2, 3, 4, 5], value);
        }
        get write_metadata() {
            return pb_1.Message.getWrapperField(this, InstructionWriteMetadata, 3) as InstructionWriteMetadata;
        }
        set write_metadata(value: InstructionWriteMetadata) {
            pb_1.Message.setOneofWrapperField(this, 3, [2, 3, 4, 5], value);
        }
        get actions() {
            return pb_1.Message.getWrapperField(this, InstructionActions, 4) as InstructionActions;
        }
        set actions(value: InstructionActions) {
            pb_1.Message.setOneofWrapperField(this, 4, [2, 3, 4, 5], value);
        }
        get meter() {
            return pb_1.Message.getWrapperField(this, InstructionMeter, 5) as InstructionMeter;
        }
        set meter(value: InstructionMeter) {
            pb_1.Message.setOneofWrapperField(this, 5, [2, 3, 4, 5], value);
        }
        get data() {
            const cases: {
                [index: number]: "none" | "goto_table" | "write_metadata" | "actions" | "meter";
            } = {
                0: "none",
                2: "goto_table",
                3: "write_metadata",
                4: "actions",
                5: "meter"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2, 3, 4, 5])];
        }
        get _type() {
            const cases: {
                [index: number]: "none" | "type";
            } = {
                0: "none",
                1: "type"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        toObject() {
            const data: {
                type?: InstructionType;
                goto_table?: ReturnType<typeof InstructionGotoTable.prototype.toObject>;
                write_metadata?: ReturnType<typeof InstructionWriteMetadata.prototype.toObject>;
                actions?: ReturnType<typeof InstructionActions.prototype.toObject>;
                meter?: ReturnType<typeof InstructionMeter.prototype.toObject>;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.goto_table != null) {
                data.goto_table = this.goto_table.toObject();
            }
            if (this.write_metadata != null) {
                data.write_metadata = this.write_metadata.toObject();
            }
            if (this.actions != null) {
                data.actions = this.actions.toObject();
            }
            if (this.meter != null) {
                data.meter = this.meter.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type !== undefined)
                writer.writeEnum(1, this.type);
            if (this.goto_table !== undefined)
                writer.writeMessage(2, this.goto_table, () => this.goto_table.serialize(writer));
            if (this.write_metadata !== undefined)
                writer.writeMessage(3, this.write_metadata, () => this.write_metadata.serialize(writer));
            if (this.actions !== undefined)
                writer.writeMessage(4, this.actions, () => this.actions.serialize(writer));
            if (this.meter !== undefined)
                writer.writeMessage(5, this.meter, () => this.meter.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Instruction {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Instruction();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        reader.readMessage(message.goto_table, () => message.goto_table = InstructionGotoTable.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.write_metadata, () => message.write_metadata = InstructionWriteMetadata.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.actions, () => message.actions = InstructionActions.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.meter, () => message.meter = InstructionMeter.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Instruction {
            return Instruction.deserialize(bytes);
        }
    }
    export class InstructionGotoTable extends pb_1.Message {
        constructor(data?: any[] | {
            table_id?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("table_id" in data && data.table_id != undefined) {
                    this.table_id = data.table_id;
                }
            }
        }
        get table_id() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set table_id(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        toObject() {
            const data: {
                table_id?: number;
            } = {};
            if (this.table_id != null) {
                data.table_id = this.table_id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.table_id !== undefined)
                writer.writeUint32(1, this.table_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): InstructionGotoTable {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new InstructionGotoTable();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.table_id = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): InstructionGotoTable {
            return InstructionGotoTable.deserialize(bytes);
        }
    }
    export class InstructionWriteMetadata extends pb_1.Message {
        constructor(data?: any[] | {
            metadata?: number;
            metadata_mask?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("metadata" in data && data.metadata != undefined) {
                    this.metadata = data.metadata;
                }
                if ("metadata_mask" in data && data.metadata_mask != undefined) {
                    this.metadata_mask = data.metadata_mask;
                }
            }
        }
        get metadata() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set metadata(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get metadata_mask() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set metadata_mask(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        toObject() {
            const data: {
                metadata?: number;
                metadata_mask?: number;
            } = {};
            if (this.metadata != null) {
                data.metadata = this.metadata;
            }
            if (this.metadata_mask != null) {
                data.metadata_mask = this.metadata_mask;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.metadata !== undefined)
                writer.writeUint32(1, this.metadata);
            if (this.metadata_mask !== undefined)
                writer.writeUint32(2, this.metadata_mask);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): InstructionWriteMetadata {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new InstructionWriteMetadata();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.metadata = reader.readUint32();
                        break;
                    case 2:
                        message.metadata_mask = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): InstructionWriteMetadata {
            return InstructionWriteMetadata.deserialize(bytes);
        }
    }
    export class InstructionActions extends pb_1.Message {
        constructor(data?: any[] | {
            actions?: Action[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("actions" in data && data.actions != undefined) {
                    this.actions = data.actions;
                }
            }
        }
        get actions() {
            return pb_1.Message.getRepeatedWrapperField(this, Action, 1) as Action[];
        }
        set actions(value: Action[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        toObject() {
            const data: {
                actions?: ReturnType<typeof Action.prototype.toObject>[];
            } = {};
            if (this.actions != null) {
                data.actions = this.actions.map((item: Action) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.actions !== undefined)
                writer.writeRepeatedMessage(1, this.actions, (item: Action) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): InstructionActions {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new InstructionActions();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.actions, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Action.deserialize(reader), Action));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): InstructionActions {
            return InstructionActions.deserialize(bytes);
        }
    }
    export class InstructionMeter extends pb_1.Message {
        constructor(data?: any[] | {
            meter_id?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("meter_id" in data && data.meter_id != undefined) {
                    this.meter_id = data.meter_id;
                }
            }
        }
        get meter_id() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set meter_id(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        toObject() {
            const data: {
                meter_id?: number;
            } = {};
            if (this.meter_id != null) {
                data.meter_id = this.meter_id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.meter_id !== undefined)
                writer.writeUint32(1, this.meter_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): InstructionMeter {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new InstructionMeter();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.meter_id = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): InstructionMeter {
            return InstructionMeter.deserialize(bytes);
        }
    }
    export class Match extends pb_1.Message {
        constructor(data?: any[] | ({} & (({
            field_name?: string;
        }) | ({
            value?: string;
        }) | ({
            mask?: string;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[1], [2], [3]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("field_name" in data && data.field_name != undefined) {
                    this.field_name = data.field_name;
                }
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
                if ("mask" in data && data.mask != undefined) {
                    this.mask = data.mask;
                }
            }
        }
        get field_name() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set field_name(value: string) {
            pb_1.Message.setOneofField(this, 1, [1], value);
        }
        get value() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set value(value: string) {
            pb_1.Message.setOneofField(this, 2, [2], value);
        }
        get mask() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set mask(value: string) {
            pb_1.Message.setOneofField(this, 3, [3], value);
        }
        get _field_name() {
            const cases: {
                [index: number]: "none" | "field_name";
            } = {
                0: "none",
                1: "field_name"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        get _value() {
            const cases: {
                [index: number]: "none" | "value";
            } = {
                0: "none",
                2: "value"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        get _mask() {
            const cases: {
                [index: number]: "none" | "mask";
            } = {
                0: "none",
                3: "mask"
            };
            return cases[pb_1.Message.computeOneofCase(this, [3])];
        }
        toObject() {
            const data: {
                field_name?: string;
                value?: string;
                mask?: string;
            } = {};
            if (this.field_name != null) {
                data.field_name = this.field_name;
            }
            if (this.value != null) {
                data.value = this.value;
            }
            if (this.mask != null) {
                data.mask = this.mask;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.field_name === "string" && this.field_name.length)
                writer.writeString(1, this.field_name);
            if (typeof this.value === "string" && this.value.length)
                writer.writeString(2, this.value);
            if (typeof this.mask === "string" && this.mask.length)
                writer.writeString(3, this.mask);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Match {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Match();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.field_name = reader.readString();
                        break;
                    case 2:
                        message.value = reader.readString();
                        break;
                    case 3:
                        message.mask = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Match {
            return Match.deserialize(bytes);
        }
    }
    export class Flow extends pb_1.Message {
        constructor(data?: any[] | ({
            match?: Match[];
            actions?: Instruction[];
        } & (({
            cookie?: string;
        }) | ({
            duration?: number;
        }) | ({
            table?: number;
        }) | ({
            n_packets?: number;
        }) | ({
            n_bytes?: number;
        }) | ({
            priority?: number;
        }) | ({
            flow_id?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [7, 8], [[1], [2], [3], [4], [5], [6], [9]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("cookie" in data && data.cookie != undefined) {
                    this.cookie = data.cookie;
                }
                if ("duration" in data && data.duration != undefined) {
                    this.duration = data.duration;
                }
                if ("table" in data && data.table != undefined) {
                    this.table = data.table;
                }
                if ("n_packets" in data && data.n_packets != undefined) {
                    this.n_packets = data.n_packets;
                }
                if ("n_bytes" in data && data.n_bytes != undefined) {
                    this.n_bytes = data.n_bytes;
                }
                if ("priority" in data && data.priority != undefined) {
                    this.priority = data.priority;
                }
                if ("match" in data && data.match != undefined) {
                    this.match = data.match;
                }
                if ("actions" in data && data.actions != undefined) {
                    this.actions = data.actions;
                }
                if ("flow_id" in data && data.flow_id != undefined) {
                    this.flow_id = data.flow_id;
                }
            }
        }
        get cookie() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set cookie(value: string) {
            pb_1.Message.setOneofField(this, 1, [1], value);
        }
        get duration() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set duration(value: number) {
            pb_1.Message.setOneofField(this, 2, [2], value);
        }
        get table() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set table(value: number) {
            pb_1.Message.setOneofField(this, 3, [3], value);
        }
        get n_packets() {
            return pb_1.Message.getField(this, 4) as number;
        }
        set n_packets(value: number) {
            pb_1.Message.setOneofField(this, 4, [4], value);
        }
        get n_bytes() {
            return pb_1.Message.getField(this, 5) as number;
        }
        set n_bytes(value: number) {
            pb_1.Message.setOneofField(this, 5, [5], value);
        }
        get priority() {
            return pb_1.Message.getField(this, 6) as number;
        }
        set priority(value: number) {
            pb_1.Message.setOneofField(this, 6, [6], value);
        }
        get match() {
            return pb_1.Message.getRepeatedWrapperField(this, Match, 7) as Match[];
        }
        set match(value: Match[]) {
            pb_1.Message.setRepeatedWrapperField(this, 7, value);
        }
        get actions() {
            return pb_1.Message.getRepeatedWrapperField(this, Instruction, 8) as Instruction[];
        }
        set actions(value: Instruction[]) {
            pb_1.Message.setRepeatedWrapperField(this, 8, value);
        }
        get flow_id() {
            return pb_1.Message.getField(this, 9) as number;
        }
        set flow_id(value: number) {
            pb_1.Message.setOneofField(this, 9, [9], value);
        }
        get _cookie() {
            const cases: {
                [index: number]: "none" | "cookie";
            } = {
                0: "none",
                1: "cookie"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        get _duration() {
            const cases: {
                [index: number]: "none" | "duration";
            } = {
                0: "none",
                2: "duration"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        get _table() {
            const cases: {
                [index: number]: "none" | "table";
            } = {
                0: "none",
                3: "table"
            };
            return cases[pb_1.Message.computeOneofCase(this, [3])];
        }
        get _n_packets() {
            const cases: {
                [index: number]: "none" | "n_packets";
            } = {
                0: "none",
                4: "n_packets"
            };
            return cases[pb_1.Message.computeOneofCase(this, [4])];
        }
        get _n_bytes() {
            const cases: {
                [index: number]: "none" | "n_bytes";
            } = {
                0: "none",
                5: "n_bytes"
            };
            return cases[pb_1.Message.computeOneofCase(this, [5])];
        }
        get _priority() {
            const cases: {
                [index: number]: "none" | "priority";
            } = {
                0: "none",
                6: "priority"
            };
            return cases[pb_1.Message.computeOneofCase(this, [6])];
        }
        get _flow_id() {
            const cases: {
                [index: number]: "none" | "flow_id";
            } = {
                0: "none",
                9: "flow_id"
            };
            return cases[pb_1.Message.computeOneofCase(this, [9])];
        }
        toObject() {
            const data: {
                cookie?: string;
                duration?: number;
                table?: number;
                n_packets?: number;
                n_bytes?: number;
                priority?: number;
                match?: ReturnType<typeof Match.prototype.toObject>[];
                actions?: ReturnType<typeof Instruction.prototype.toObject>[];
                flow_id?: number;
            } = {};
            if (this.cookie != null) {
                data.cookie = this.cookie;
            }
            if (this.duration != null) {
                data.duration = this.duration;
            }
            if (this.table != null) {
                data.table = this.table;
            }
            if (this.n_packets != null) {
                data.n_packets = this.n_packets;
            }
            if (this.n_bytes != null) {
                data.n_bytes = this.n_bytes;
            }
            if (this.priority != null) {
                data.priority = this.priority;
            }
            if (this.match != null) {
                data.match = this.match.map((item: Match) => item.toObject());
            }
            if (this.actions != null) {
                data.actions = this.actions.map((item: Instruction) => item.toObject());
            }
            if (this.flow_id != null) {
                data.flow_id = this.flow_id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.cookie === "string" && this.cookie.length)
                writer.writeString(1, this.cookie);
            if (this.duration !== undefined)
                writer.writeFloat(2, this.duration);
            if (this.table !== undefined)
                writer.writeSint32(3, this.table);
            if (this.n_packets !== undefined)
                writer.writeSint32(4, this.n_packets);
            if (this.n_bytes !== undefined)
                writer.writeSint32(5, this.n_bytes);
            if (this.priority !== undefined)
                writer.writeSint32(6, this.priority);
            if (this.match !== undefined)
                writer.writeRepeatedMessage(7, this.match, (item: Match) => item.serialize(writer));
            if (this.actions !== undefined)
                writer.writeRepeatedMessage(8, this.actions, (item: Instruction) => item.serialize(writer));
            if (this.flow_id !== undefined)
                writer.writeSint32(9, this.flow_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Flow {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Flow();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.cookie = reader.readString();
                        break;
                    case 2:
                        message.duration = reader.readFloat();
                        break;
                    case 3:
                        message.table = reader.readSint32();
                        break;
                    case 4:
                        message.n_packets = reader.readSint32();
                        break;
                    case 5:
                        message.n_bytes = reader.readSint32();
                        break;
                    case 6:
                        message.priority = reader.readSint32();
                        break;
                    case 7:
                        reader.readMessage(message.match, () => pb_1.Message.addToRepeatedWrapperField(message, 7, Match.deserialize(reader), Match));
                        break;
                    case 8:
                        reader.readMessage(message.actions, () => pb_1.Message.addToRepeatedWrapperField(message, 8, Instruction.deserialize(reader), Instruction));
                        break;
                    case 9:
                        message.flow_id = reader.readSint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Flow {
            return Flow.deserialize(bytes);
        }
    }
    export class FlowTable extends pb_1.Message {
        constructor(data?: any[] | {
            flows?: Flow[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("flows" in data && data.flows != undefined) {
                    this.flows = data.flows;
                }
            }
        }
        get flows() {
            return pb_1.Message.getRepeatedWrapperField(this, Flow, 1) as Flow[];
        }
        set flows(value: Flow[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        toObject() {
            const data: {
                flows?: ReturnType<typeof Flow.prototype.toObject>[];
            } = {};
            if (this.flows != null) {
                data.flows = this.flows.map((item: Flow) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.flows !== undefined)
                writer.writeRepeatedMessage(1, this.flows, (item: Flow) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FlowTable {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FlowTable();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.flows, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Flow.deserialize(reader), Flow));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FlowTable {
            return FlowTable.deserialize(bytes);
        }
    }
    export class PacketProcessing extends pb_1.Message {
        constructor(data?: any[] | ({
            pkts?: Packet[];
            matched_flows?: number[];
        } & (({
            switch?: string;
        }) | ({
            flow_table?: FlowTable;
        }) | ({
            action_set?: ActionSet;
        }) | ({
            packet_after_action_set?: Packet;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2, 3], [[1], [4], [5], [6]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("switch" in data && data.switch != undefined) {
                    this.switch = data.switch;
                }
                if ("flow_table" in data && data.flow_table != undefined) {
                    this.flow_table = data.flow_table;
                }
                if ("action_set" in data && data.action_set != undefined) {
                    this.action_set = data.action_set;
                }
                if ("pkts" in data && data.pkts != undefined) {
                    this.pkts = data.pkts;
                }
                if ("matched_flows" in data && data.matched_flows != undefined) {
                    this.matched_flows = data.matched_flows;
                }
                if ("packet_after_action_set" in data && data.packet_after_action_set != undefined) {
                    this.packet_after_action_set = data.packet_after_action_set;
                }
            }
        }
        get switch() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set switch(value: string) {
            pb_1.Message.setOneofField(this, 1, [1], value);
        }
        get flow_table() {
            return pb_1.Message.getWrapperField(this, FlowTable, 4) as FlowTable;
        }
        set flow_table(value: FlowTable) {
            pb_1.Message.setOneofWrapperField(this, 4, [4], value);
        }
        get action_set() {
            return pb_1.Message.getWrapperField(this, ActionSet, 5) as ActionSet;
        }
        set action_set(value: ActionSet) {
            pb_1.Message.setOneofWrapperField(this, 5, [5], value);
        }
        get pkts() {
            return pb_1.Message.getRepeatedWrapperField(this, Packet, 2) as Packet[];
        }
        set pkts(value: Packet[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get matched_flows() {
            return pb_1.Message.getField(this, 3) as number[];
        }
        set matched_flows(value: number[]) {
            pb_1.Message.setField(this, 3, value);
        }
        get packet_after_action_set() {
            return pb_1.Message.getWrapperField(this, Packet, 6) as Packet;
        }
        set packet_after_action_set(value: Packet) {
            pb_1.Message.setOneofWrapperField(this, 6, [6], value);
        }
        get _switch() {
            const cases: {
                [index: number]: "none" | "switch";
            } = {
                0: "none",
                1: "switch"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        get _flow_table() {
            const cases: {
                [index: number]: "none" | "flow_table";
            } = {
                0: "none",
                4: "flow_table"
            };
            return cases[pb_1.Message.computeOneofCase(this, [4])];
        }
        get _action_set() {
            const cases: {
                [index: number]: "none" | "action_set";
            } = {
                0: "none",
                5: "action_set"
            };
            return cases[pb_1.Message.computeOneofCase(this, [5])];
        }
        get _packet_after_action_set() {
            const cases: {
                [index: number]: "none" | "packet_after_action_set";
            } = {
                0: "none",
                6: "packet_after_action_set"
            };
            return cases[pb_1.Message.computeOneofCase(this, [6])];
        }
        toObject() {
            const data: {
                switch?: string;
                flow_table?: ReturnType<typeof FlowTable.prototype.toObject>;
                action_set?: ReturnType<typeof ActionSet.prototype.toObject>;
                pkts?: ReturnType<typeof Packet.prototype.toObject>[];
                matched_flows?: number[];
                packet_after_action_set?: ReturnType<typeof Packet.prototype.toObject>;
            } = {};
            if (this.switch != null) {
                data.switch = this.switch;
            }
            if (this.flow_table != null) {
                data.flow_table = this.flow_table.toObject();
            }
            if (this.action_set != null) {
                data.action_set = this.action_set.toObject();
            }
            if (this.pkts != null) {
                data.pkts = this.pkts.map((item: Packet) => item.toObject());
            }
            if (this.matched_flows != null) {
                data.matched_flows = this.matched_flows;
            }
            if (this.packet_after_action_set != null) {
                data.packet_after_action_set = this.packet_after_action_set.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.switch === "string" && this.switch.length)
                writer.writeString(1, this.switch);
            if (this.flow_table !== undefined)
                writer.writeMessage(4, this.flow_table, () => this.flow_table.serialize(writer));
            if (this.action_set !== undefined)
                writer.writeMessage(5, this.action_set, () => this.action_set.serialize(writer));
            if (this.pkts !== undefined)
                writer.writeRepeatedMessage(2, this.pkts, (item: Packet) => item.serialize(writer));
            if (this.matched_flows !== undefined)
                writer.writePackedSint32(3, this.matched_flows);
            if (this.packet_after_action_set !== undefined)
                writer.writeMessage(6, this.packet_after_action_set, () => this.packet_after_action_set.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PacketProcessing {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PacketProcessing();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.switch = reader.readString();
                        break;
                    case 4:
                        reader.readMessage(message.flow_table, () => message.flow_table = FlowTable.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.action_set, () => message.action_set = ActionSet.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.pkts, () => pb_1.Message.addToRepeatedWrapperField(message, 2, Packet.deserialize(reader), Packet));
                        break;
                    case 3:
                        pb_1.Message.addToRepeatedField(message, 3, reader.readPackedSint32());
                        break;
                    case 6:
                        reader.readMessage(message.packet_after_action_set, () => message.packet_after_action_set = Packet.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PacketProcessing {
            return PacketProcessing.deserialize(bytes);
        }
    }
    export class PacketArc extends pb_1.Message {
        constructor(data?: any[] | ({} & (({
            src?: string;
        }) | ({
            pkt?: Packet;
        }) | ({
            packet_processing?: PacketProcessing;
        }) | ({
            edge?: string;
        }) | ({
            dst?: string;
        }) | ({
            dst_interface?: string;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[1], [2], [4], [5], [3], [6]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("src" in data && data.src != undefined) {
                    this.src = data.src;
                }
                if ("pkt" in data && data.pkt != undefined) {
                    this.pkt = data.pkt;
                }
                if ("packet_processing" in data && data.packet_processing != undefined) {
                    this.packet_processing = data.packet_processing;
                }
                if ("edge" in data && data.edge != undefined) {
                    this.edge = data.edge;
                }
                if ("dst" in data && data.dst != undefined) {
                    this.dst = data.dst;
                }
                if ("dst_interface" in data && data.dst_interface != undefined) {
                    this.dst_interface = data.dst_interface;
                }
            }
        }
        get src() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set src(value: string) {
            pb_1.Message.setOneofField(this, 1, [1], value);
        }
        get pkt() {
            return pb_1.Message.getWrapperField(this, Packet, 2) as Packet;
        }
        set pkt(value: Packet) {
            pb_1.Message.setOneofWrapperField(this, 2, [2], value);
        }
        get packet_processing() {
            return pb_1.Message.getWrapperField(this, PacketProcessing, 4) as PacketProcessing;
        }
        set packet_processing(value: PacketProcessing) {
            pb_1.Message.setOneofWrapperField(this, 4, [4], value);
        }
        get edge() {
            return pb_1.Message.getField(this, 5) as string;
        }
        set edge(value: string) {
            pb_1.Message.setOneofField(this, 5, [5], value);
        }
        get dst() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set dst(value: string) {
            pb_1.Message.setOneofField(this, 3, [3], value);
        }
        get dst_interface() {
            return pb_1.Message.getField(this, 6) as string;
        }
        set dst_interface(value: string) {
            pb_1.Message.setOneofField(this, 6, [6], value);
        }
        get _src() {
            const cases: {
                [index: number]: "none" | "src";
            } = {
                0: "none",
                1: "src"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        get _pkt() {
            const cases: {
                [index: number]: "none" | "pkt";
            } = {
                0: "none",
                2: "pkt"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        get _packet_processing() {
            const cases: {
                [index: number]: "none" | "packet_processing";
            } = {
                0: "none",
                4: "packet_processing"
            };
            return cases[pb_1.Message.computeOneofCase(this, [4])];
        }
        get _edge() {
            const cases: {
                [index: number]: "none" | "edge";
            } = {
                0: "none",
                5: "edge"
            };
            return cases[pb_1.Message.computeOneofCase(this, [5])];
        }
        get _dst() {
            const cases: {
                [index: number]: "none" | "dst";
            } = {
                0: "none",
                3: "dst"
            };
            return cases[pb_1.Message.computeOneofCase(this, [3])];
        }
        get _dst_interface() {
            const cases: {
                [index: number]: "none" | "dst_interface";
            } = {
                0: "none",
                6: "dst_interface"
            };
            return cases[pb_1.Message.computeOneofCase(this, [6])];
        }
        toObject() {
            const data: {
                src?: string;
                pkt?: ReturnType<typeof Packet.prototype.toObject>;
                packet_processing?: ReturnType<typeof PacketProcessing.prototype.toObject>;
                edge?: string;
                dst?: string;
                dst_interface?: string;
            } = {};
            if (this.src != null) {
                data.src = this.src;
            }
            if (this.pkt != null) {
                data.pkt = this.pkt.toObject();
            }
            if (this.packet_processing != null) {
                data.packet_processing = this.packet_processing.toObject();
            }
            if (this.edge != null) {
                data.edge = this.edge;
            }
            if (this.dst != null) {
                data.dst = this.dst;
            }
            if (this.dst_interface != null) {
                data.dst_interface = this.dst_interface;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.src === "string" && this.src.length)
                writer.writeString(1, this.src);
            if (this.pkt !== undefined)
                writer.writeMessage(2, this.pkt, () => this.pkt.serialize(writer));
            if (this.packet_processing !== undefined)
                writer.writeMessage(4, this.packet_processing, () => this.packet_processing.serialize(writer));
            if (typeof this.edge === "string" && this.edge.length)
                writer.writeString(5, this.edge);
            if (typeof this.dst === "string" && this.dst.length)
                writer.writeString(3, this.dst);
            if (typeof this.dst_interface === "string" && this.dst_interface.length)
                writer.writeString(6, this.dst_interface);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PacketArc {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PacketArc();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.src = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.pkt, () => message.pkt = Packet.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.packet_processing, () => message.packet_processing = PacketProcessing.deserialize(reader));
                        break;
                    case 5:
                        message.edge = reader.readString();
                        break;
                    case 3:
                        message.dst = reader.readString();
                        break;
                    case 6:
                        message.dst_interface = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PacketArc {
            return PacketArc.deserialize(bytes);
        }
    }
    export class PacketTrace extends pb_1.Message {
        constructor(data?: any[] | ({
            arcs?: PacketArc[];
        } & (({
            protocol?: string;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], [[2]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("arcs" in data && data.arcs != undefined) {
                    this.arcs = data.arcs;
                }
                if ("protocol" in data && data.protocol != undefined) {
                    this.protocol = data.protocol;
                }
            }
        }
        get arcs() {
            return pb_1.Message.getRepeatedWrapperField(this, PacketArc, 1) as PacketArc[];
        }
        set arcs(value: PacketArc[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get protocol() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set protocol(value: string) {
            pb_1.Message.setOneofField(this, 2, [2], value);
        }
        get _protocol() {
            const cases: {
                [index: number]: "none" | "protocol";
            } = {
                0: "none",
                2: "protocol"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        toObject() {
            const data: {
                arcs?: ReturnType<typeof PacketArc.prototype.toObject>[];
                protocol?: string;
            } = {};
            if (this.arcs != null) {
                data.arcs = this.arcs.map((item: PacketArc) => item.toObject());
            }
            if (this.protocol != null) {
                data.protocol = this.protocol;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.arcs !== undefined)
                writer.writeRepeatedMessage(1, this.arcs, (item: PacketArc) => item.serialize(writer));
            if (typeof this.protocol === "string" && this.protocol.length)
                writer.writeString(2, this.protocol);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PacketTrace {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PacketTrace();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.arcs, () => pb_1.Message.addToRepeatedWrapperField(message, 1, PacketArc.deserialize(reader), PacketArc));
                        break;
                    case 2:
                        message.protocol = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PacketTrace {
            return PacketTrace.deserialize(bytes);
        }
    }
    export class StartTracingRequest extends pb_1.Message {
        constructor(data?: any[] | ({} & (({
            option?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[1]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("option" in data && data.option != undefined) {
                    this.option = data.option;
                }
            }
        }
        get option() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set option(value: number) {
            pb_1.Message.setOneofField(this, 1, [1], value);
        }
        get _option() {
            const cases: {
                [index: number]: "none" | "option";
            } = {
                0: "none",
                1: "option"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        toObject() {
            const data: {
                option?: number;
            } = {};
            if (this.option != null) {
                data.option = this.option;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.option !== undefined)
                writer.writeSint32(1, this.option);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StartTracingRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StartTracingRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.option = reader.readSint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StartTracingRequest {
            return StartTracingRequest.deserialize(bytes);
        }
    }
    export class StopTracingRequest extends pb_1.Message {
        constructor(data?: any[] | ({} & (({
            option?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[1]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("option" in data && data.option != undefined) {
                    this.option = data.option;
                }
            }
        }
        get option() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set option(value: number) {
            pb_1.Message.setOneofField(this, 1, [1], value);
        }
        get _option() {
            const cases: {
                [index: number]: "none" | "option";
            } = {
                0: "none",
                1: "option"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        toObject() {
            const data: {
                option?: number;
            } = {};
            if (this.option != null) {
                data.option = this.option;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.option !== undefined)
                writer.writeSint32(1, this.option);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StopTracingRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StopTracingRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.option = reader.readSint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StopTracingRequest {
            return StopTracingRequest.deserialize(bytes);
        }
    }
    export class GetTraceRequest extends pb_1.Message {
        constructor(data?: any[] | ({} & (({
            option?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[1]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("option" in data && data.option != undefined) {
                    this.option = data.option;
                }
            }
        }
        get option() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set option(value: number) {
            pb_1.Message.setOneofField(this, 1, [1], value);
        }
        get _option() {
            const cases: {
                [index: number]: "none" | "option";
            } = {
                0: "none",
                1: "option"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        toObject() {
            const data: {
                option?: number;
            } = {};
            if (this.option != null) {
                data.option = this.option;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.option !== undefined)
                writer.writeSint32(1, this.option);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetTraceRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetTraceRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.option = reader.readSint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetTraceRequest {
            return GetTraceRequest.deserialize(bytes);
        }
    }
    export class GetTraceResult extends pb_1.Message {
        constructor(data?: any[] | {
            packet_traces?: PacketTrace[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("packet_traces" in data && data.packet_traces != undefined) {
                    this.packet_traces = data.packet_traces;
                }
            }
        }
        get packet_traces() {
            return pb_1.Message.getRepeatedWrapperField(this, PacketTrace, 1) as PacketTrace[];
        }
        set packet_traces(value: PacketTrace[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        toObject() {
            const data: {
                packet_traces?: ReturnType<typeof PacketTrace.prototype.toObject>[];
            } = {};
            if (this.packet_traces != null) {
                data.packet_traces = this.packet_traces.map((item: PacketTrace) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.packet_traces !== undefined)
                writer.writeRepeatedMessage(1, this.packet_traces, (item: PacketTrace) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetTraceResult {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetTraceResult();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.packet_traces, () => pb_1.Message.addToRepeatedWrapperField(message, 1, PacketTrace.deserialize(reader), PacketTrace));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetTraceResult {
            return GetTraceResult.deserialize(bytes);
        }
    }
    export class TopoChangeResult extends pb_1.Message {
        constructor(data?: any[] | ({} & (({
            status?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[1]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("status" in data && data.status != undefined) {
                    this.status = data.status;
                }
            }
        }
        get status() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set status(value: number) {
            pb_1.Message.setOneofField(this, 1, [1], value);
        }
        get _status() {
            const cases: {
                [index: number]: "none" | "status";
            } = {
                0: "none",
                1: "status"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        toObject() {
            const data: {
                status?: number;
            } = {};
            if (this.status != null) {
                data.status = this.status;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.status !== undefined)
                writer.writeSint32(1, this.status);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TopoChangeResult {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TopoChangeResult();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.status = reader.readSint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TopoChangeResult {
            return TopoChangeResult.deserialize(bytes);
        }
    }
    export class HostCommand extends pb_1.Message {
        constructor(data?: any[] | ({} & (({
            host?: string;
        }) | ({
            command?: string;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[1], [2]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("host" in data && data.host != undefined) {
                    this.host = data.host;
                }
                if ("command" in data && data.command != undefined) {
                    this.command = data.command;
                }
            }
        }
        get host() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set host(value: string) {
            pb_1.Message.setOneofField(this, 1, [1], value);
        }
        get command() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set command(value: string) {
            pb_1.Message.setOneofField(this, 2, [2], value);
        }
        get _host() {
            const cases: {
                [index: number]: "none" | "host";
            } = {
                0: "none",
                1: "host"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        get _command() {
            const cases: {
                [index: number]: "none" | "command";
            } = {
                0: "none",
                2: "command"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        toObject() {
            const data: {
                host?: string;
                command?: string;
            } = {};
            if (this.host != null) {
                data.host = this.host;
            }
            if (this.command != null) {
                data.command = this.command;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.host === "string" && this.host.length)
                writer.writeString(1, this.host);
            if (typeof this.command === "string" && this.command.length)
                writer.writeString(2, this.command);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): HostCommand {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new HostCommand();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.host = reader.readString();
                        break;
                    case 2:
                        message.command = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): HostCommand {
            return HostCommand.deserialize(bytes);
        }
    }
    export class MininetCommand extends pb_1.Message {
        constructor(data?: any[] | ({} & (({
            command?: string;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[1]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("command" in data && data.command != undefined) {
                    this.command = data.command;
                }
            }
        }
        get command() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set command(value: string) {
            pb_1.Message.setOneofField(this, 1, [1], value);
        }
        get _command() {
            const cases: {
                [index: number]: "none" | "command";
            } = {
                0: "none",
                1: "command"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        toObject() {
            const data: {
                command?: string;
            } = {};
            if (this.command != null) {
                data.command = this.command;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.command === "string" && this.command.length)
                writer.writeString(1, this.command);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MininetCommand {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MininetCommand();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.command = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MininetCommand {
            return MininetCommand.deserialize(bytes);
        }
    }
    export class CommandResult extends pb_1.Message {
        constructor(data?: any[] | ({} & (({
            type?: CommandResultType;
        }) | ({
            result?: string;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[1], [2]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("result" in data && data.result != undefined) {
                    this.result = data.result;
                }
            }
        }
        get type() {
            return pb_1.Message.getField(this, 1) as CommandResultType;
        }
        set type(value: CommandResultType) {
            pb_1.Message.setOneofField(this, 1, [1], value);
        }
        get result() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set result(value: string) {
            pb_1.Message.setOneofField(this, 2, [2], value);
        }
        get _type() {
            const cases: {
                [index: number]: "none" | "type";
            } = {
                0: "none",
                1: "type"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        get _result() {
            const cases: {
                [index: number]: "none" | "result";
            } = {
                0: "none",
                2: "result"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        toObject() {
            const data: {
                type?: CommandResultType;
                result?: string;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.result != null) {
                data.result = this.result;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type !== undefined)
                writer.writeEnum(1, this.type);
            if (typeof this.result === "string" && this.result.length)
                writer.writeString(2, this.result);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CommandResult {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CommandResult();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        message.result = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CommandResult {
            return CommandResult.deserialize(bytes);
        }
    }
}
